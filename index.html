<!doctype html>
<html lang="he" dir="rtl">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Crowd Podcast Correction Interface</title>
  <style>
    /* Diff colors like your demo */
    #diffBody {
      white-space: pre-wrap;
      line-height: 1.9;
      /* match transcript */
      font-size: var(--text-size);
      /* match transcript */
      font-family: "Noto Sans Hebrew", "Rubik", Arial, sans-serif;
    }



    :root {
      --text-size: 1.10rem;
      --gutter-size: 6px;
      --bg: #0b0f14;
      --panel: #121926;
      --ink: #e6edf3;
      --muted: #9fb0c0;
      --brand: #78b6ff;
      --accent: #ffd36e;
      --danger: #ff7a7a;
      --focus: #78b6ff;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box
    }



    body {
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", "Helvetica Neue", Arial;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    a {
      color: var(--brand)
    }

    a:focus-visible {
      outline: 2px solid var(--focus);
      outline-offset: 2px
    }

    .visually-hidden {
      position: absolute !important;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0 0 0 0);
      white-space: nowrap;
      border: 0
    }

    /* Selection */
    ::selection {
      background: rgba(120, 182, 255, .35)
    }

    /* Inputs pick up the brand */
    input[type="checkbox"],
    input[type="range"] {
      accent-color: var(--brand)
    }

    .wrap {
      display: grid;
      grid-template-rows: auto 1fr;
      height: 100%;
    }

    header {
      position: sticky;
      top: 0;
      z-index: 5;
      background: linear-gradient(180deg, rgba(18, 25, 38, .98), rgba(18, 25, 38, .94));
      border-bottom: 1px solid rgba(255, 255, 255, .06);
      backdrop-filter: blur(6px)
    }

    .bar {
      display: flex;
      gap: .6rem;
      flex-wrap: wrap;
      align-items: center;
      padding: .6rem .9rem
    }

    .bar label {
      font-size: .85rem;
      color: var(--muted)
    }

    .bar button {
      background: #0e1523;
      border: 1px solid rgba(255, 255, 255, .12);
      color: var(--ink);
      padding: .45rem .6rem;
      border-radius: .6rem;
      cursor: pointer;
      font-family: inherit
    }

    .bar button.primary {
      background: linear-gradient(180deg, #2a6aff, #275ae0);
      border-color: rgba(0, 0, 0, .2)
    }

    button:focus-visible {
      outline: 2px solid var(--focus);
      outline-offset: 2px
    }

    button:disabled {
      opacity: .6;
      cursor: not-allowed
    }

    .hidden {
      display: none
    }

    #panel {
      /* start values so you can see them change in DevTools */
      --w-nav: 380px;
      --w-diff: 380px;

      display: grid;
      grid-template-columns: var(--w-nav) 6px 1fr 6px var(--w-diff);
      grid-template-areas: "browser gutR transcript gutL diff";

    }


    /* Give transcript & diff their own scrollbars */
    #transcript,
    #diffBody {
      max-height: calc(100vh - 100px);
      /* tweak if needed */
      overflow: auto;
    }


    /* Responsive breakpoints */
    @media (max-width:1100px) {
      #panel {
        grid-template-columns: minmax(300px, 520px) 1fr
      }
    }

    @media (max-width:780px) {
      #panel {
        grid-template-columns: 1fr;
        grid-auto-rows: minmax(0, auto)
      }
    }



    /* שיוכים לגריד */
    #diffCard {
      grid-area: diff;
    }

    #transcriptCard {
      grid-area: transcript;
    }

    #browserCard {
      grid-area: browser;

    }

    #gutterL {
      grid-area: gutL;
    }

    #gutterR {
      grid-area: gutR;
    }

    .gutter {
      background: rgba(255, 255, 255, .08);
      cursor: col-resize;
    }

    .gutter:hover {
      background: rgba(255, 255, 255, .18)
    }

    .diff-insert {
      background: #d4fcdc;
      color: #064e0d;
    }

    .diff-delete {
      background: #ffe2e2;
      color: #a00;
      text-decoration: line-through;
    }

    .diff-equal {
      color: inherit;
    }

    html,
    body {
      height: 100%
    }

    * {
      scrollbar-width: none;
      /* Firefox */
      -ms-overflow-style: none;
      /* IE/Edge Legacy */
    }

    *::-webkit-scrollbar {
      display: none;
    }

    /* Chromium/Safari */
    .card {
      background: var(--panel);

      overflow: visible;
      max-height: calc(100vh - 56px);
    }

    .card .head {
      padding: 0rem .9rem;
      margin: 0.5rem;
      color: var(--muted);
      font-size: .9rem;
      display: flex;
      align-items: center;
      gap: .6rem;
      justify-content: space-between
    }


    .card .body {
      margin: 0.4rem;
      max-height: calc(100% - 42px);
      overflow: auto
    }

    /* Browser panes */
    #browserGrid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: .8rem;
      height: 100%;
      overflow: visible;
    }

    @media (max-width:780px) {
      #browserGrid {
        grid-template-columns: 1fr
      }
    }

    .pane {
      display: flex;
      flex-direction: column;
      min-height: 0;
      border: 1px solid rgba(255, 255, 255, .08);
      border-radius: 10px
    }

    .pane h4 {
      margin: 0;
      padding: .45rem .6rem;
      border-bottom: 1px solid rgba(255, 255, 255, .06);
      color: var(--muted);
      font-size: .9rem
    }

    .pane .list {
      flex: 1 1 auto;
      overflow: auto;
      padding: .5rem;
      display: grid;
      gap: .35rem;
      align-content: start;
      list-style: none;
      margin: 0
    }

    .item {
      padding: .35rem .5rem;
      border-radius: .5rem;
      border: 1px solid rgba(255, 255, 255, .06);
      cursor: pointer;
      width: 100%;
      text-align: right;
      background: none;
      color: inherit;
      font: inherit;
      overflow: ;
    }

    .item:hover {
      background: #0e1523
    }

    .item.active {
      background: rgba(120, 182, 255, .14);
      border-color: rgba(120, 182, 255, .3)
    }

    .item.loading {
      cursor: wait;
      opacity: .6
    }

    .item:focus-visible {
      outline: 2px solid var(--focus);
      outline-offset: 2px
    }

    audio {
      width: 30%;
      height: 36px
    }

    .controls {
      padding: 0rem .9rem;

      color: var(--muted);
      font-size: .9rem;
      display: flex;
      align-items: center;

      justify-content: space-between
    }

    .pill {
      background: #0e1523;
      border: 1px solid rgba(255, 255, 255, .08);
      padding: .3rem .6rem;
      border-radius: 999px;
      font-size: .85rem;
      color: var(--muted);
      user-select: none;
      cursor: pointer
    }



    /* Ensure A−/A+ have sufficient contrast */
    #fontMinus,
    #fontPlus {
      padding: .5rem .7rem;
      min-width: 2.2rem;
      background-color: #4f4dd1;
      color: var(--ink)
        /* override .pill muted text */
    }

    /* Save button visibility */
    #submitBtn {
      font-size: .9rem;
      padding: .4rem .7rem;
      min-width: 2.2rem;
      color: #0b0f14;
      background-color: #00ff0db7;
      font-weight: 600
    }

    /* Transcript look */
    .transcript {
      white-space: pre-wrap;
      line-height: 1.9;
      font-size: var(--text-size);
      font-family: "Noto Sans Hebrew", "Rubik", Arial, sans-serif;
      caret-color: var(--accent);
    }

    .word {
      padding: 0;
      border-radius: .35rem;
      transition: background-color .15s ease;
      cursor: pointer
    }

    .word:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px
    }

    .word.active {
      background: rgba(255, 211, 110, .25);
      box-shadow: 0 0 0 1px rgba(255, 211, 110, .25) inset
    }

    /* Highlights */
    .word.added-lite {
      background: rgba(0, 255, 0, .10)
    }

    .word.deleted {
      text-decoration: line-through;
      background: rgba(200, 0, 0, .12);
      opacity: .85
    }

    .hint {
      color: var(--muted);
      font-size: .9rem
    }

    .err {
      color: var(--danger)
    }


    /* Modal */
    .modal {
      position: fixed;
      inset: 0;
      display: none;
      place-items: center;
      background: rgba(0, 0, 0, .4);
      z-index: 50
    }

    .modal.open {
      display: grid
    }

    .sheet {
      width: min(520px, 94vw);
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, .08);
      border-radius: 12px;
      overflow: hidden
    }

    .sheet h3 {
      margin: 0;
      padding: .8rem 1rem;
      border-bottom: 1px solid rgba(255, 255, 255, .06);
      color: var(--muted);
      font-size: 1rem
    }

    .sheet .p {
      padding: 1rem
    }

    .sheet .row {
      margin: .5rem 0
    }

    .sheet .actions {
      display: flex;
      gap: .5rem;
      justify-content: flex-end;
      padding: 0 1rem 1rem
    }

    h2 {
      margin: -0.1rem;
      margin-bottom: 0.1remZ;
    }

    /* Back-to-top button (RTL: keep it on the RIGHT) */
    #scrollTopBtn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 100;
      display: none;
      background: rgba(221, 221, 221, .685);
      color: #000;
      /* better contrast on light BG */
      border: none;
      border-radius: 50%;
      width: 44px;
      height: 44px;
      font-size: 1.2rem;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, .4)
    }

    #scrollTopBtn:hover {
      background: #5596e6;
      color: #fff
    }

    /* Native audio controls theming (WebKit only).
   NOTE: #9cc2fa with white text had poor contrast; use dark text. */
    audio::-webkit-media-controls-panel {
      background-color: #9cc2fa;
      color: #000000;
      /* remove invalid unitless margins/paddings from previous version */
    }

    /* Range input hit area improvements (lightweight) */
    input[type="range"] {
      touch-action: manipulation;
      inline-size: 160px;
    }

    /* Reduced motion: minimize animations */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: .001ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: .001ms !important;
        scroll-behavior: auto !important
      }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header role="banner">


      <section class="card" id="playerCard" aria-labelledby="playerCardTitle">
        <h2 id="playerCardTitle" class="visually-hidden">נגן אודיו</h2>
        <div class="head">


          <button id="settingsBtn" type="button" aria-haspopup="dialog" aria-controls="modal" title="הגדרות">⚙️</button>


          <details class="hint" id="kbdHelp">
            <summary aria-label="קיצורי מקלדת">⌨️ קיצורים</summary>
            <div>
              קליק ימני לעריכת הטקסט · Enter לשמירה · Esc לביטול · Ctrl+Z לביטול · Ctrl+Shift+Z לשחזור
            </div>
          </details>



          <button class="pill" id="dlVtt" type="button" title="הורד VTT" aria-label="הורד VTT">⬇️ VTT</button>
          <audio id="player" controls crossorigin="anonymous" preload="metadata" aria-describedby="meta err"></audio>

          <label for="rate">מהירות:</label>
          <input id="rate" type="range" min="0.3" max="3" step="0.05" value="1" aria-describedby="rateVal" />
          <span id="rateVal" class="hint" role="status" aria-live="polite">×1.00</span>


        </div>
      </section>
    </header>

    <main id="panel">


      <section class="card" id="browserCard" aria-labelledby="browserCardTitle">
        <div class="head">
          <h2 id="browserCardTitle"> דפדוף • audio-v2-opus</h2>

        </div>

        <div class="body" id="browser">
          <nav id="browserGrid" aria-label="דפדוף בתיקיות וקבצים">
            <div class="pane">
              <h3>תיקיות</h3>
              <ul class="list" id="folders" role="list"></ul>
            </div>
            <div class="pane">
              <h3>קבצים</h3>
              <ul class="list" id="files" role="list"></ul>
            </div>
          </nav>
        </div>
      </section>


      <div id="gutterR" class="gutter" role="separator" aria-orientation="vertical" tabindex="0"></div>


      <section class="card" id="transcriptCard" aria-labelledby="transcriptCardTitle">
        <div class="head">
          <h2 id="transcriptCardTitle">תמליל</h2>
          <div role="group" aria-label="פקדי תמליל">
            <button id="submitBtn" class="pill" type="button" aria-controls="transcript">⬆️ שמור תיקון</button>
            <button id="fontMinus" class="pill" type="button" aria-controls="transcript" title="הקטן גופן">A−</button>
            <button id="fontPlus" class="pill" type="button" aria-controls="transcript" title="הגדל גופן">A+</button>
          </div>
        </div>
        <div id="transcript" class=" transcript" dir="auto" aria-label="תצוגת התמליל לעריכה"></div>
      </section>


      <div id="gutterL" class="gutter" role="separator" aria-orientation="vertical" tabindex="0"></div>

      <section class="card" id="diffCard" aria-labelledby="diffCardTitle">
        <div class="head">
          <h2 id="diffCardTitle" class="diffCardTitle">
            השוואה בין HF למצב הנוכחי
          </h2>
        </div>
        <div id="diffBody" class="" dir="auto"></div>
      </section>


      <!-- Modal -->
      <div id="modal" class="modal" aria-hidden="true">
        <div class="sheet" role="dialog" aria-modal="true" aria-labelledby="t" aria-describedby="tDesc" tabindex="-1">
          <h3 id="t">Hugging Face Token</h3>
          <p id="tDesc" class="hint">האסימון נשמר מקומית בלבד ונשלח רק ל-huggingface.co.</p>
          <div class="p">
            <div class="row">
              <input id="hfToken" name="hfToken" type="password" placeholder="hf_XXXXXXXXXXXXXXXXXX" style="width:100%"
                dir="ltr" inputmode="text" autocomplete="off" autocapitalize="off" spellcheck="false" translate="no" />
            </div>
            <p class="hint">קבצי אודיו נטענים כ-Blob כאשר נדרש.</p>
          </div>
          <div class="actions">
            <button id="mClear" type="button">נקה</button>
            <button id="mClose" type="button">סגור</button>
            <button id="mSave" class="primary" type="button">שמור</button>
          </div>
        </div>
      </div>

      <button id="scrollTopBtn" type="button" title="חזור למעלה" aria-label="חזור למעלה">⬆️</button>

      <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
      <!-- Load Supabase client -->
      <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

      <script type="module">
        import DiffMatchPatch from "https://esm.sh/diff-match-patch@1.0.5";
        const DMP = new DiffMatchPatch();
        const diffBody = document.getElementById('diffBody');

        (async () => {

          // ===== Supabase setup =====
          const { createClient } = supabase;
          const supabaseUrl = "https://xblbzxyyoptnfrlffigv.supabase.co";
          const supabaseKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhibGJ6eHl5b3B0bmZybGZmaWd2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU3ODI1MjgsImV4cCI6MjA3MTM1ODUyOH0.eIB279AoKwL5mrXuX1BQxa1mevVXMPrZK2VLaZ5kTNE";
          const supa = createClient(supabaseUrl, supabaseKey);

          // ====== El refs
          const $ = (id) => document.getElementById(id);
          const err = $('err');
          const player = $('player'), tr = $('transcript')
          const rate = $('rate'), rateVal = $('rateVal');
          const settingsBtn = $('settingsBtn'), dlVttBtn = $('dlVtt');
          const modal = $('modal'), hfTokenInput = $('hfToken'); const mSave = $('mSave'), mClose = $('mClose'), mClear = $('mClear');
          const foldersEl = $('folders'), filesEl = $('files');
          const browserCard = $('browserCard');
          const transcriptEl = $('transcript');
          const fontMinus = $('fontMinus');
          const fontPlus = $('fontPlus');

          // ====== State
          let data = { text: '', segments: [] };
          let wordEls = [], starts = [], ends = [], lastIdx = -1, objUrl = null;
          let editingFull = { active: false, resume: false, original: '', caret: 0 };
          let editBox = null; // contentEditable div
          let currentFileNode = null;
          let correctionsCache = new Set();
          let lastLoad = { controller: null, token: 0 };
          let hfBaselineText = '';   // טקסט המקור מ-HF לצורך diff

          // Baseline/current token streams (flattened, include \n tokens)
          let baselineTokens = []; // immutable
          let currentTokens = [];  // mutable, with state: 'keep'|'ins'|'del'

          // History for undo/redo (snapshots of currentTokens)
          let undoStack = [], redoStack = [];

          const TOKEN_KEY = 'hfToken';
          const getTok = () => localStorage.getItem(TOKEN_KEY) || '';
          const setTok = t => t ? localStorage.setItem(TOKEN_KEY, t) : localStorage.removeItem(TOKEN_KEY);

          // ====== Utils
          const isHf = u => { try { const h = new URL(u).host; return h.endsWith('huggingface.co') || h.endsWith('hf.co') } catch { return false } };
          const encPath = p => p.split('/').map(encodeURIComponent).join('/');
          const hfRes = (path, ds) => `https://huggingface.co/datasets/ivrit-ai/${ds}/resolve/main/${encPath(path)}`;
          const opusUrl = (path) => hfRes(path, 'audio-v2-opus');
          const transUrl = (path) => hfRes(path, 'audio-v2-transcripts');
          const normPaths = (folder, file) => ({ audioPath: `${folder}/${file}`, trPath: `${folder}/${file.replace(/\.opus$/i, '')}/full_transcript.json.gz` });
          const t2 = t => { if (!Number.isFinite(t)) return '—'; const s = ('0' + Math.floor(t % 60)).slice(-2), m = ('0' + Math.floor(t / 60 % 60)).slice(-2), h = Math.floor(t / 3600); return h ? `${h}:${m}:${s}` : `${m}:${s}` };
          const fetchAuth = (u, o = {}) => { const h = new Headers(o.headers || {}); if (!h.has('Accept')) h.set('Accept', 'application/json'); if (getTok() && isHf(u)) h.set('Authorization', 'Bearer ' + getTok()); return fetch(u, { ...o, headers: h, mode: 'cors', redirect: 'follow' }); };
          const clearTr = () => { tr.innerHTML = ''; wordEls = []; starts = []; ends = []; lastIdx = -1 };
          const deepCopy = x => JSON.parse(JSON.stringify(x));


          await loadAllCorrections();

          function tokenize(text) {
            const out = [];
            let buf = "";
            for (const ch of Array.from(text)) {
              if (/\s/u.test(ch)) {        // whitespace char
                if (buf) { out.push(buf); buf = ""; }
                out.push(ch);             // ONE token per whitespace char
              } else {                    // non-whitespace
                buf += ch;                // accumulate run
              }
            }
            if (buf) out.push(buf);
            return out;
          }

          // Flatten data.segments -> tokens (inserting \n between segments)
          function flattenToTokens(d) {
            const toks = []; let lastEnd = 0;
            d.segments.forEach((s, si) => {
              s.words.forEach(w => { toks.push({ word: String(w.word || ''), start: +w.start || 0, end: +w.end || ((+w.start || 0) + .25), state: 'keep' }); lastEnd = toks[toks.length - 1].end; });
              if (si < d.segments.length - 1) { toks.push({ word: '\n', start: lastEnd, end: lastEnd, state: 'keep' }); }
            });
            return toks;
          }

          const wordsToText = (words) => words.filter(w => w.state !== "del").map(w => w.word).join('');


          // Use normalized baseline so LCS aligns unchanged tokens;
          // unchanged words keep EXACT timestamps; only inserts get interpolated.
          function buildFromBaseline(baselineTokens, newText) {
            const A = normalizeBaselineForDiff(baselineTokens);   // [{word,start,end}]
            const B = tokenize(newText);                          // [" ", "מילה", " ", ...]
            const aWords = A.map(w => w.word);

            // LCS table
            const m = aWords.length, n = B.length;
            const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
            for (let i = m - 1; i >= 0; i--) {
              for (let j = n - 1; j >= 0; j--) {
                dp[i][j] = (aWords[i] === B[j]) ? dp[i + 1][j + 1] + 1 : Math.max(dp[i + 1][j], dp[i][j + 1]);
              }
            }

            // Backtrack → ops
            const out = [];
            let i = 0, j = 0;
            while (i < m && j < n) {
              if (aWords[i] === B[j]) {
                const w = A[i++];
                out.push({ word: w.word, start: w.start, end: w.end, state: 'keep' }); // exact times preserved
                j++;
              } else if (dp[i + 1][j] >= dp[i][j + 1]) {
                const w = A[i++];
                out.push({ word: w.word, start: w.start, end: w.end, state: 'del' });
              } else {
                out.push({ word: B[j++], start: NaN, end: NaN, state: 'ins' });
              }
            }
            while (i < m) { const w = A[i++]; out.push({ word: w.word, start: w.start, end: w.end, state: 'del' }); }
            while (j < n) { out.push({ word: B[j++], start: NaN, end: NaN, state: 'ins' }); }

            assignTimesFromAnchors(out); // only modifies 'ins'
            repairChronology(out);
            return out;
          }

          // Helper: split each baseline token into whitespace/non-whitespace runs,
          // and apportion the token’s original time across the runs so unchanged
          // runs keep their exact/relative timestamps.
          // Keep timestamps of unchanged WORDS EXACTLY;
          // split baseline tokens into WS/non-WS runs BUT
          // give WS runs zero-duration anchors so they never
          // shift word timings.
          function normalizeBaselineForDiff(baselineTokens) {
            // Baseline from the model may contain leading/trailing spaces inside a single token.
            // We split into runs, but:
            //  - non-WS run (the "word") keeps the FULL original token start/end
            //  - WS runs become zero-duration anchors located proportionally inside the token span
            const out = [];
            const isWS = (s) => /^\s+$/u.test(s);

            for (const t of baselineTokens) {
              const txt = String(t.word || '');
              if (txt === '') { out.push({ word: '', start: t.start, end: t.end }); continue; }

              const parts = txt.match(/\s+|\S+/gu) || [txt];
              let pos = 0;
              for (const p of parts) {
                const from = pos;
                const to = pos + p.length;
                pos = to;

                if (isWS(p)) {
                  // Zero-duration anchor inside the token span
                  const span = Math.max(0, (t.end || 0) - (t.start || 0));
                  const L = Math.max(1, txt.length);
                  const anchor = (t.start || 0) + span * (from / L);
                  out.push({ word: p, start: anchor, end: anchor });
                } else {
                  // Preserve the ENTIRE original token timing for the word piece
                  out.push({ word: p, start: t.start, end: t.end });
                }
              }
            }
            return out;
          }

          // Drop-in replacement
          function assignTimesFromAnchors(arr) {
            const EPS = 1e-3;           // 1 ms
            const MIN_WORD_DUR = 0.02;  // 20 ms
            const isWS = s => /^\s$/u.test(s);

            const isWordKeep = w =>
              w.state === 'keep' && !isWS(w.word) &&
              Number.isFinite(w.start) && Number.isFinite(w.end) && w.end > w.start;

            const isAnyKeep = w =>
              w.state === 'keep' &&
              Number.isFinite(w.start) && Number.isFinite(w.end);

            function leftAnchor(i) {
              for (let k = i - 1; k >= 0; k--) {
                if (arr[k].state === 'keep' && arr[k].word === '\n') return null;
                if (isWordKeep(arr[k])) return arr[k];
              }
              for (let k = i - 1; k >= 0; k--) {
                if (arr[k].state === 'keep' && arr[k].word === '\n') return null;
                if (isAnyKeep(arr[k])) return arr[k];
              }
              return null;
            }

            function rightAnchor(i) {
              for (let k = i + 1; k < arr.length; k++) {
                if (arr[k].state === 'keep' && arr[k].word === '\n') return null;
                if (isWordKeep(arr[k])) return arr[k];
              }
              for (let k = i + 1; k < arr.length; k++) {
                if (arr[k].state === 'keep' && arr[k].word === '\n') return null;
                if (isAnyKeep(arr[k])) return arr[k];
              }
              return null;
            }

            let i = 0;
            while (i < arr.length) {
              if (arr[i].state !== 'ins') { i++; continue; }
              let j = i; while (j < arr.length && arr[j].state === 'ins') j++;

              const L = leftAnchor(i), R = rightAnchor(j - 1);
              const slice = arr.slice(i, j);
              const wordIdxs = slice.map((t, ix) => (/^\s$/u.test(t.word) ? -1 : ix)).filter(ix => ix >= 0);
              const wordCount = wordIdxs.length;

              let winStart, winEnd;
              const winLenFor = n => Math.max(0.12 * Math.max(1, n), 0.12);

              if (L && R && R.start > L.end) { winStart = L.end; winEnd = R.start; }
              else if (L) { winStart = L.end; winEnd = L.end + winLenFor(wordCount); }
              else if (R) { winEnd = R.start; winStart = R.start - winLenFor(wordCount); }
              else { winStart = 0; winEnd = winLenFor(wordCount); }

              if (winEnd <= winStart) winEnd = winStart + winLenFor(wordCount);

              if (wordCount > 0) {
                const step = (winEnd - winStart) / (wordCount + 1);
                let nthWord = 0;
                let prevAssigned = Number.isFinite(L?.end) ? L.end : -Infinity;

                for (let k = 0; k < slice.length; k++) {
                  const g = arr[i + k];

                  if (isWS(g.word)) {
                    let anchor = winStart + (winEnd - winStart) * ((k + 1) / (slice.length + 1));
                    anchor = Math.max(anchor, prevAssigned + EPS, winStart + EPS);
                    if (R) anchor = Math.min(anchor, R.start - EPS);
                    g.start = g.end = anchor;
                    prevAssigned = g.start;
                    continue;
                  }

                  nthWord++;
                  const center = winStart + step * nthWord;
                  let s = center - step * 0.45;                          // preserve your spacing feel
                  s = Math.max(s, prevAssigned + EPS, winStart + EPS);
                  if (R) s = Math.min(s, R.start - EPS);
                  let e = s + Math.max(MIN_WORD_DUR, step * 0.9);
                  if (R && e > R.start - EPS) e = Math.max(s + MIN_WORD_DUR, R.start - EPS);

                  g.start = s; g.end = e;
                  prevAssigned = g.start;
                }
              } else {
                // Only whitespace → anchor at mid (clamped)
                let a = winStart + (winEnd - winStart) / 2;
                if (L) a = Math.max(a, L.end + EPS);
                if (R) a = Math.min(a, R.start - EPS);
                for (let k = 0; k < slice.length; k++) {
                  const g = arr[i + k];
                  g.start = g.end = a;
                }
              }

              // Local monotonicity inside the slice
              (function monotonicize(leftBound) {
                let last = Number.isFinite(leftBound) ? leftBound : -Infinity;
                for (let k = i; k < j; k++) {
                  const g = arr[k], ws = isWS(g.word);
                  if (!Number.isFinite(g.start)) g.start = last + EPS;
                  if (g.start < last - EPS) g.start = last + EPS;
                  if (!Number.isFinite(g.end)) g.end = g.start + (ws ? 0 : MIN_WORD_DUR);
                  if (g.end < g.start) g.end = g.start + (ws ? 0 : MIN_WORD_DUR);
                  last = g.start;
                }
              })(L?.end);

              i = j;
            }

            // Global sweep: if anything (including kept WS) still steps back, nudge forward.
            let prev = -Infinity;
            for (let k = 0; k < arr.length; k++) {
              const t = arr[k];
              if (t.state === 'del' || t.word === '\n') continue;
              const ws = isWS(t.word);

              if (!Number.isFinite(t.start)) t.start = prev + EPS;
              if (!Number.isFinite(t.end)) t.end = t.start + (ws ? 0 : MIN_WORD_DUR);

              if (t.start < prev - EPS) {
                // we will adjust inserted tokens OR any whitespace; also fix obviously-bad kept words
                if (t.state === 'ins' || ws || t.end < prev) {
                  t.start = prev + EPS;
                  if (t.end < t.start) t.end = t.start + (ws ? 0 : MIN_WORD_DUR);
                }
              }
              prev = Math.max(prev, t.start);
            }
          }
          function repairChronology(tokens) {
            const EPS = 1e-3, MIN_WORD_DUR = 0.02;
            const isWS = s => /^\s$/u.test(s);

            let prev = -Infinity;
            for (let i = 0; i < tokens.length; i++) {
              const t = tokens[i];
              if (t.state === 'del' || t.word === '\n') continue;

              const ws = isWS(t.word);
              if (!Number.isFinite(t.start)) t.start = prev + EPS;
              if (!Number.isFinite(t.end)) t.end = t.start + (ws ? 0 : MIN_WORD_DUR);

              if (t.start < prev - EPS) {
                // As a last resort, nudge any offender forward (kept or inserted).
                t.start = prev + EPS;
                if (t.end < t.start) t.end = t.start + (ws ? 0 : MIN_WORD_DUR);
              }
              prev = Math.max(prev, t.start);
            }
          }

          function render() {
            if (editingFull.active) return;
            clearTr();
            const f = document.createDocumentFragment();

            currentTokens.forEach((w, ti) => {
              // ⛔️ Don't render deleted tokens at all
              if (w.state === 'del') return;

              if (w.word === '\n') {
                f.appendChild(document.createTextNode('\n'));
                return;
              }

              const sp = document.createElement('span');
              sp.className = 'word';            // keep transcript clean: no diff classes
              sp.textContent = w.word;
              sp.dataset.start = w.start;
              sp.dataset.end = w.end;
              sp.dataset.ti = ti;

              f.appendChild(sp);

              // only non-deleted words are navigable/highlightable
              wordEls.push(sp);
              starts.push(w.start);
              ends.push(w.end);
            });

            tr.appendChild(f);
          }


          // ====== Word interactions (Event Delegation)
          tr.onclick = e => {
            const el = e.target.closest('.word');
            if (el && !el.classList.contains('deleted')) {
              const t = +el.dataset.start; if (!editingFull.active) { player.currentTime = t + .01; player.play(); }
            }
          };

          // Precise caret placement via right-click
          tr.oncontextmenu = e => {
            e.preventDefault();
            const el = e.target.closest('.word'); if (!el) return;
            const ti = +el.dataset.ti;
            let charOffsetInWord = el.textContent.length; // default: end
            try {
              if (document.caretPositionFromPoint) { const pos = document.caretPositionFromPoint(e.clientX, e.clientY); if (pos && el.contains(pos.offsetNode)) charOffsetInWord = pos.offset; }
              else if (document.caretRangeFromPoint) { const r = document.caretRangeFromPoint(e.clientX, e.clientY); if (r && el.contains(r.startContainer)) charOffsetInWord = r.startOffset; }
            } catch { }
            startFullEditAtTokenIndex(ti, charOffsetInWord);
          };

          // ====== Full-text edit mode
          function getFullText() { return wordsToText(currentTokens); }

          function getAbsIndexBeforeToken(ti) { // counts only non-deleted tokens, includes newlines
            let off = 0; for (let i = 0; i < ti; i++) { if (currentTokens[i].state !== 'del') off += (currentTokens[i].word || '').length; } return off;
          }

          function ensureEditUI() {
            if (editBox) return;

            editBox = document.createElement('div');
            editBox.id = 'editBox';
            editBox.contentEditable = 'true';
            editBox.spellcheck = false;
            editBox.className = 'transcript';
            Object.assign(editBox.style, {
              minHeight: '40vh',
              outline: 'none',
              fontSize: getComputedStyle(transcriptEl).fontSize // <-- key line
            });

            tr.innerHTML = '';
            tr.appendChild(editBox);

            // ENTER commits (no Ctrl+Enter); ESC cancels
            editBox.addEventListener('keydown', (e) => {
              if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); commitFullEdit();
              } else if (e.key === 'Escape') {
                e.preventDefault(); cancelFullEdit();
              }
            });
            editBox.addEventListener('input', renderDiff);
            // One-time global: left-click outside transcript commits and resumes
            if (!ensureEditUI._outsideBound) {
              document.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                if (editingFull.active && editBox && !tr.contains(e.target)) {
                  e.preventDefault();
                  commitFullEdit();
                }
              }, true);
              ensureEditUI._outsideBound = true;
            }
          }




          function placeCaret(container, index) {
            const range = document.createRange(); const sel = window.getSelection();
            // normalize to single text node for reliable offsets
            container.textContent = container.textContent;
            const textNode = container.firstChild || container;
            const len = (textNode.textContent || '').length;
            range.setStart(textNode, Math.max(0, Math.min(len, index)));
            range.collapse(true); sel.removeAllRanges(); sel.addRange(range); container.focus();
          }

          function startFullEditAtTokenIndex(ti, charOffsetInWord) {
            const resume = !player.paused && !player.ended; try { player.pause() } catch { }
            ensureEditUI();
            const fullText = getFullText();
            editingFull.active = true; editingFull.resume = resume; editingFull.original = fullText;
            editBox.textContent = fullText;
            const caretPos = getAbsIndexBeforeToken(ti) + Math.min(charOffsetInWord, (currentTokens[ti].word || '').length);
            requestAnimationFrame(() => placeCaret(editBox, caretPos));
          }

          function snapshot() { return deepCopy(currentTokens); }


          function commitFullEdit() {
            if (!editingFull.active) return;
            const resume = !!editingFull.resume;

            const newText = (editBox && (editBox.innerText || '')).replace(/\r/g, '');
            if (newText === (editingFull.original || '')) {
              editingFull = { active: false, resume: false, original: '', caret: 0 };
              editBox = null;
              render();
              renderDiff();
              if (resume && !player.ended) { try { player.play(); } catch { } }
              return;
            }

            // ✅ Save state for undo before applying change
            undoStack.push(snapshot());
            redoStack = [];

            currentTokens = buildFromBaseline(baselineTokens, newText);
            data = tokensToData(currentTokens);

            editingFull = { active: false, resume: false, original: '', caret: 0 };
            editBox = null;
            render();
            renderDiff();
            if (resume && !player.ended) { try { player.play(); } catch { } }
          }


          function cancelFullEdit() {
            if (!editingFull.active) return; const resume = editingFull.resume;
            editingFull = { active: false, resume: false, original: '', caret: 0 }; editBox = null; render();
            renderDiff();
            if (resume && !player.ended) try { player.play() } catch { };
          }

          // Global Undo/Redo (works on any keyboard layout + Mac/Windows/Linux)
          document.addEventListener('keydown', (e) => {
            const isZ = (e.code === 'KeyZ'); // layout-independent physical Z key
            const isUndo = (e.ctrlKey || e.metaKey) && isZ && !e.shiftKey;
            const isRedo = (e.ctrlKey || e.metaKey) && isZ && e.shiftKey;

            if (isUndo) {
              e.preventDefault();
              if (undoStack.length) {
                redoStack.push(snapshot());
                currentTokens = undoStack.pop();
                data = tokensToData(currentTokens);
                render();
                if (editBox) editBox.textContent = getFullText();
                renderDiff(); // <-- add this
              }
            } else if (isRedo) {
              e.preventDefault();
              if (redoStack.length) {
                undoStack.push(snapshot());
                currentTokens = redoStack.pop();
                data = tokensToData(currentTokens);
                render();
                renderDiff();
                if (editBox) editBox.textContent = getFullText();
              }
            }
          });


          function tokensToData(tokens) {
            const text = wordsToText(tokens);
            const segs = [];
            let words = [];
            let pendingWS = '';
            let pendingS = Infinity;
            for (const t of tokens) {
              if (t.state === 'del') continue;
              if (t.word === '\n') {
                // ignore trailing pendingWS
                segs.push(words);
                words = [];
                pendingWS = '';
                pendingS = Infinity;
                continue;
              }
              const is_ws = /^\s$/u.test(t.word);
              if (is_ws) {
                pendingWS += t.word;
                if (Number.isFinite(t.start)) pendingS = Math.min(pendingS, t.start);
              } else {
                const start = Number.isFinite(pendingS) ? Math.min(pendingS, t.start) : t.start;
                words.push({ word: pendingWS + t.word, start, end: t.end });
                pendingWS = '';
                pendingS = Infinity;
              }
            }
            if (words.length) segs.push(words);
            return {
              text, segments: segs.map(ws => {
                const startsArr = ws.filter(w => Number.isFinite(w.start)).map(w => w.start);
                const endsArr = ws.filter(w => Number.isFinite(w.end)).map(w => w.end);
                const t0 = startsArr.length > 0 ? Math.min(...startsArr) : 0;
                const t1 = endsArr.length > 0 ? Math.max(...endsArr) : 0.25;
                return { start: t0, end: t1, text: ws.map(w => w.word).join(''), words };
              })
            };
          }

          // ====== Browser (folders/files)
          function extractItems(json) { if (Array.isArray(json)) return json; if (json && Array.isArray(json.items)) return json.items; if (json && Array.isArray(json.tree)) return json.tree; if (json && Array.isArray(json.siblings)) return json.siblings; return []; }
          function filterImmediate(items, base) { const depth = base ? base.split('/').filter(Boolean).length : 0; return items.filter(x => { const p = x.path || x.rpath || ''; if (base && !p.startsWith(base + '/')) return false; const d = p.split('/').filter(Boolean).length; return d === depth + 1; }); }
          async function listTree(path = '') {
            const base = 'https://huggingface.co/api/datasets/ivrit-ai/audio-v2-opus/tree/main';
            const urls = path ? [`${base}/${encPath(path)}`, `${base}?path=${encodeURIComponent(path)}`] : [base, `${base}?recursive=false`];
            let lastErr = null; for (const url of urls) { try { const r = await fetchAuth(url, { headers: { Accept: 'application/json' } }); if (r.status === 401 && !getTok()) throw new Error('401: דרוש hf_ token לדפדוף'); if (!r.ok) { lastErr = new Error('שגיאת רשת (' + r.status + ') בדפדוף'); continue; } const j = await r.json(); return filterImmediate(extractItems(j), path || ''); } catch (e) { lastErr = e; } } throw lastErr || new Error('שגיאה בדפדוף');
          }
          async function loadFolders() { foldersEl.innerHTML = '<div class="hint">טוען תיקיות…</div>'; try { const items = await listTree(''); const dirs = items.filter(x => (x.type === 'directory' || x.type === 'tree' || x.type === 'dir')).map(x => x.path.split('/').pop()).sort((a, b) => a.localeCompare(b, 'he')); foldersEl.innerHTML = dirs.map(d => `<button class=\"item\" data-folder=\"${d}\">${d}</button>`).join(''); } catch (e) { foldersEl.innerHTML = `<div class="err">${e.message || e}</div>`; } }
          foldersEl.onclick = e => { const item = e.target.closest('.item[data-folder]'); if (item) selectFolder(item.dataset.folder, item); };

          // ====== Helper to paint one file red/green ======
          function markFile(filePath, hasCorrection) {
            const fileName = filePath.split("/").pop();
            const el = filesEl.querySelector(`[data-file="${fileName}"]`);
            if (!el) return;
            el.style.background = hasCorrection
              ? "rgba(0,255,0,.08)"  // green
              : "rgba(255,0,0,.08)"; // red
          }
          async function fetchCorrections(filePaths) {
            const results = [];
            const chunkSize = 50;
            for (let i = 0; i < filePaths.length; i += chunkSize) {
              const chunk = filePaths.slice(i, i + chunkSize);
              const { data, error } = await supa
                .from("corrections")
                .select("file_path")
                .in("file_path", chunk);
              if (error) throw error;
              results.push(...data);
            }
            return results;
          }

          async function loadAllCorrections() {
            try {
              const { data, error } = await supa
                .from("corrections")
                .select("file_path");

              if (error) throw error;

              correctionsCache = new Set(data.map(r => r.file_path));
              console.log("✅ Corrections loaded:", correctionsCache.size);
            } catch (e) {
              console.error("❌ Failed to load corrections:", e.message || e);
            }
          }
          // ====== Select folder and render files ======
          async function selectFolder(folder, node) {
            // highlight active folder in sidebar
            [...foldersEl.children].forEach(el =>
              el.classList.toggle("active", el === node)
            );

            filesEl.innerHTML = '<div class="hint">טוען קבצים…</div>';

            try {
              const items = await listTree(folder);

              const files = items
                .filter(x => {
                  const t = (x.type || "").toLowerCase();
                  const p = x.path || "";
                  return (
                    t === "file" ||
                    t === "blob" ||
                    t === "lfs" ||
                    p.toLowerCase().endsWith(".opus")
                  );
                })
                .map(x => (x.path || "").split("/").pop())
                .sort((a, b) => a.localeCompare(b, "he"));

              if (!files.length) {
                filesEl.innerHTML = '<div class="hint">אין קבצי OPUS בתיקייה זו</div>';
                return;
              }

              filesEl.innerHTML = files
                .map(f => {
                  const displayName = f.replace(/\.opus$/i, ""); // strip extension
                  return `<button class="item" data-folder="${folder}" data-file="${f}">${displayName}</button>`;
                })
                .join("");

              // ===== crosscheck corrections from cache =====
              files.forEach(f => {
                const fp = folder + "/" + f;
                markFile(fp, correctionsCache.has(fp));
              });

            } catch (e) {
              filesEl.innerHTML = `<div class="err">${e.message || e}</div>`;
            }
          }


          function escapeHtml(text) {
            return String(text).replace(/[&<>"']/g, c => (
              { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c]
            ));
          }

          // Current plain text for diff: if editing, use live content; else use tokens
          function getCurrentPlainText() {
            if (editBox && editingFull.active) {
              return (editBox.innerText || '').replace(/\r/g, '');
            }
            // wordsToText already exists in your code
            return wordsToText(currentTokens.filter(t => t.state !== 'del'));
          }

          function renderDiff() {
            if (!diffBody) return;

            const base = hfBaselineText || '';
            const cur = getCurrentPlainText();

            if (!base) {
              diffBody.textContent = cur;
              return;
            }

            const diffs = DMP.diff_main(base, cur);
            DMP.diff_cleanupSemantic(diffs);

            diffBody.innerHTML = diffs.map(([op, data]) => {
              if (op === 1) return `<span class="diff-insert">${escapeHtml(data)}</span>`;
              if (op === -1) return `<span class="diff-delete">${escapeHtml(data)}</span>`;
              return `<span class="diff-equal">${escapeHtml(data)}</span>`;
            }).join('');
          }


          (function setupGutters() {
            const gutL = document.getElementById('gutterL');       // between transcript & diff
            const gutR = document.getElementById('gutterR');       // between browser & transcript
            const panelEl = document.getElementById('panel');
            const diffCard = document.getElementById('diffCard');
            const browserCard = document.getElementById('browserCard');

            if (!gutL || !gutR || !panelEl || !diffCard || !browserCard) return;

            const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

            let dragging = null;

            function onMove(e) {
              if (!dragging) return;
              const x = e.clientX;

              if (dragging.which === 'L') {
                // Resize DIFF width
                let newW;
                if (dragging.diffIsLeftOfGutter) {
                  // diff column is to the LEFT of the gutter → width grows from panel LEFT
                  newW = clamp(x - dragging.panelRect.left, 7, 640);
                } else {
                  // diff column is to the RIGHT of the gutter → width grows from panel RIGHT
                  newW = clamp(dragging.panelRect.right - x, 7, 640);
                }
                panelEl.style.setProperty('--w-diff', newW + 'px');
              } else if (dragging.which === 'R') {
                // Resize BROWSER width
                let newW;
                if (dragging.browserIsRightOfGutter) {
                  // browser is to the RIGHT of the gutter (typical LTR order)
                  newW = clamp(dragging.panelRect.right - x, 7, 1680);
                } else {
                  // browser is to the LEFT of the gutter (RTL visual order)
                  newW = clamp(x - dragging.panelRect.left, 7, 1680);
                }
                panelEl.style.setProperty('--w-nav', newW + 'px');
              }
            }

            function stop() {
              if (!dragging) return;
              // remove text-select suppression
              document.body.style.userSelect = dragging.prevUserSelect || '';
              dragging = null;
              window.removeEventListener('mousemove', onMove);
              window.removeEventListener('mouseup', stop);
            }

            function start(which, e) {
              const panelRect = panelEl.getBoundingClientRect();

              // Figure out where the controlled column is **relative to the gutter** at drag start
              if (which === 'L') {
                const gutRect = gutL.getBoundingClientRect();
                const diffRect = diffCard.getBoundingClientRect();
                dragging = {
                  which,
                  panelRect,
                  prevUserSelect: document.body.style.userSelect,
                  // is the diff column visually to the left of the gutter?
                  diffIsLeftOfGutter: diffRect.left < gutRect.left
                };
              } else {
                const gutRect = gutR.getBoundingClientRect();
                const brRect = browserCard.getBoundingClientRect();
                dragging = {
                  which,
                  panelRect,
                  prevUserSelect: document.body.style.userSelect,
                  // is the browser column visually to the right of the gutter?
                  browserIsRightOfGutter: brRect.right > gutRect.right
                };
              }

              // suppress text selection while dragging
              document.body.style.userSelect = 'none';

              window.addEventListener('mousemove', onMove);
              window.addEventListener('mouseup', stop);
            }

            gutL.addEventListener('mousedown', (e) => { e.preventDefault(); start('L', e); });
            gutR.addEventListener('mousedown', (e) => { e.preventDefault(); start('R', e); });

            // Keyboard nudges still work the same way
            function nudge(which, dx) {
              const cs = getComputedStyle(panelEl);
              const prop = which === 'L' ? '--w-diff' : '--w-nav';
              const cur = parseFloat(cs.getPropertyValue(prop)) || (which === 'L' ? 360 : 380);
              const next = (which === 'L')
                ? clamp(cur + dx, 220, 640)
                : clamp(cur + dx, 240, 680);
              panelEl.style.setProperty(prop, next + 'px');
            }
            gutL.addEventListener('keydown', (e) => {
              if (e.key === 'ArrowLeft') nudge('L', -10);
              if (e.key === 'ArrowRight') nudge('L', 10);
            });
            gutR.addEventListener('keydown', (e) => {
              if (e.key === 'ArrowLeft') nudge('R', -10);
              if (e.key === 'ArrowRight') nudge('R', 10);
            });
          })();



          function validateChronology(tokens) {
            const EPS = 1e-3;
            const issues = [];
            let prevStart = -Infinity;

            tokens.forEach((t, i) => {
              if (t.state === 'del' || t.word === '\n') return;

              const s = t.start, e = t.end;
              const label = `${i}:${JSON.stringify(t.word)}`;

              if (!Number.isFinite(s) || !Number.isFinite(e)) {
                issues.push(`NaN/Non-finite time at ${label} start=${s} end=${e}`);
                return;
              }
              if (e < s - EPS) issues.push(`end<start at ${label} (${s}→${e})`);
              if (s < prevStart - EPS) issues.push(`non-monotonic start at ${label} (${s} < prev ${prevStart})`);

              prevStart = Math.max(prevStart, s);
            });

            if (issues.length) {
              console.error('⛔ Token chronology issues:\n' + issues.join('\n'));
              alert(
                'בעיית כרונולוגיה בזמנים:\n' +
                issues.slice(0, 30).join('\n') +
                (issues.length > 30 ? `\n…ועוד ${issues.length - 30}` : '')
              );
              return false;
            }
            return true;
          }

          (function setupScrollSync() {
            const trBody = document.getElementById('transcript'); // זה כבר .body
            if (!trBody || !diffBody) return;

            trBody.addEventListener('scroll', () => {
              const src = trBody;
              const dst = diffBody;
              const srcMax = Math.max(1, src.scrollHeight - src.clientHeight);
              const dstMax = Math.max(1, dst.scrollHeight - dst.clientHeight);
              const p = src.scrollTop / srcMax;
              dst.scrollTop = p * dstMax;
            }, { passive: true });
          })();

          filesEl.onclick = e => { const item = e.target.closest('.item[data-file]'); if (item) selectEpisode(item.dataset.folder, item.dataset.file, item); };
          function selectEpisode(folder, file, node) { if (node) { if (currentFileNode) currentFileNode.classList.remove('active'); currentFileNode = node; currentFileNode.classList.add('active'); } const { audioPath, trPath } = normPaths(folder, file); load(audioPath, trPath); }


          // ====== Load (audio + transcript) ======
          async function load(audioPath, trPath) {
            if (currentFileNode) currentFileNode.classList.add("loading");

            // בטל טעינה קודמת, והכן זיהוי חד-חד ערכי לטעינה הנוכחית
            const token = ++lastLoad.token;
            lastLoad.controller?.abort();
            const ac = new AbortController();
            lastLoad.controller = ac;

            try {
              clearTr();
              undoStack = [];
              redoStack = [];

              // --- 1) ננסה להביא תיקון מ-Supabase
              let corrected = null;
              try {
                const { data, error } = await supa
                  .from("corrections")
                  .select("json_data")
                  .eq("file_path", audioPath)
                  .maybeSingle();

                if (error) {
                  console.warn("Supabase fetch error:", error);
                } else if (data) {
                  corrected = data.json_data;
                  console.log("✅ Loaded corrected JSON from Supabase");
                  markFile(audioPath, true);
                }
              } catch (dbErr) {
                console.warn("Supabase query failed:", dbErr);
              }
              if (token !== lastLoad.token) return; // טעינה בוטלה/התיישנה

              // --- 2) תמיד להביא HF transcript לצורך diff מול המקור
              // (גם אם כבר יש 'corrected')
              let hfRaw = null;
              try {
                const trUrl = transUrl(trPath);
                let r = await fetchAuth(trUrl, { signal: ac.signal });
                if (r.status === 401 && !getTok())
                  throw new Error("401: דרוש hf_ token לתמליל");
                if (!r.ok) throw new Error("שגיאת רשת (" + r.status + ") בתמליל");

                let txt;
                const ct = (r.headers.get("content-type") || "").toLowerCase();
                if (ct.includes("application/gzip") || trPath.endsWith(".gz")) {
                  const ab = await r.arrayBuffer();
                  txt = new TextDecoder("utf-8").decode(
                    pako.ungzip(new Uint8Array(ab))
                  );
                } else {
                  txt = await r.text();
                }
                hfRaw = JSON.parse(txt);
              } catch (e) {
                // אם נכשלנו ב-HF (למשל ללא טוקן) – נמשיך בלי diff, אבל נדווח
                console.warn("HF transcript fetch failed (diff baseline):", e);
              }
              if (token !== lastLoad.token) return;

              // --- 3) נרמל את ה-HF לטקסט baseline ל-diff (אם קיים)
              if (hfRaw) {
                const hfNorm = normData(hfRaw);
                const hfTokens = flattenToTokens(hfNorm).map(t => ({
                  word: t.word, start: t.start, end: t.end, state: "keep"
                }));
                hfBaselineText = wordsToText(hfTokens);
              } else {
                hfBaselineText = '';
              }

              // --- 4) קבע את הדאטה הפעיל לתצוגה (תיקון אם יש, אחרת HF)
              if (corrected) {
                data = normData(corrected);
              } else {
                // לא היה תיקון → נטען מה-HF שהבאנו בשלב 2
                if (!hfRaw) throw new Error("שגיאה: כנראה לא הכנסת טוקן. לחץ על גלגל השיניים והכנס טוקן.");
                data = normData(hfRaw);
                markFile(audioPath, false);
              }

              // tokens לרינדור/עריכה
              baselineTokens = flattenToTokens(data);
              currentTokens = baselineTokens.map(t => ({
                word: t.word, start: t.start, end: t.end, state: "keep"
              }));
              repairChronology(currentTokens);

              data = tokensToData(currentTokens);
              render();
              if (typeof renderDiff === 'function') renderDiff(); // אם הוגדר (ראה סעיף diff)

              if (token !== lastLoad.token) return;

              // --- 5) טעינת האודיו
              const aUrl = opusUrl(audioPath);
              if (getTok() && isHf(aUrl)) {
                const ar = await fetchAuth(aUrl, { signal: ac.signal });
                if (ar.status === 401)
                  throw new Error("401: דרוש hf_ token לאודיו");
                if (!ar.ok) throw new Error("שגיאה (" + ar.status + ") באודיו");
                const b = await ar.blob();
                if (objUrl) URL.revokeObjectURL(objUrl);
                objUrl = URL.createObjectURL(b);
                player.src = objUrl;
              } else {
                player.src = aUrl;
              }
              if (token !== lastLoad.token) return;

              // --- 6) מטא/מהירות/התחלה
              player.playbackRate = parseFloat(rate.value) || 1;
              const nice = (() => {
                try { return decodeURIComponent(new URL(aUrl).pathname.split("/").pop()); }
                catch { return aUrl; }
              })();
              player.currentTime = 0.01;

            } catch (e) {
              if (e.name === 'AbortError') return; // בוטל – אין מה לדווח
              alert(e.message || e);
            } finally {
              if (currentFileNode) currentFileNode.classList.remove("loading");
            }
          }





          // ====== Normalization helper (unchanged core)


          const normData = raw => { const d = JSON.parse(JSON.stringify(raw || {})); d.text = d.text || ''; d.segments = Array.isArray(d.segments) ? d.segments : []; d.segments.forEach(s => { if (!Array.isArray(s.words) || !s.words.length) { s.words = [{ word: s.text || ' ', start: +s.start || 0, end: +s.end || (+s.start || 0) + .5 }] } else s.words.forEach(w => { w.start = +w.start || 0; w.end = +w.end || w.start + .25; w.word = String(w.word || '') }) }); return d };

          // ====== Exports (use currentTokens, preserve whitespace, ignore deleted tokens)
          const vttTime = t => {
            const h = ('0' + Math.floor(t / 3600)).slice(-2),
              m = ('0' + Math.floor(t % 3600 / 60)).slice(-2),
              s = ('0' + Math.floor(t % 60)).slice(-2),
              ms = ('00' + Math.floor((t % 1) * 1000)).slice(-3);
            return `${h}:${m}:${s}.${ms}`;
          };

          function buildVtt() {
            // נרצה להתריע גם כאן אם יש בעיות
            if (!validateChronology(currentTokens)) {
              // אם לא כרונולוגי – כבר הופיע alert. אפשר לעצור או להמשיך.
              // נעצור כדי לא להפיק VTT שגוי:
              throw new Error('הטוקנים אינם כרונולוגיים – לא ניתן להפיק VTT');
            }

            let out = 'WEBVTT\n\n';
            let cueWords = [], cueStart = null, cueEnd = null, cueIndex = 1;
            const problems = [];

            function flush() {
              if (!cueWords.length) return;
              if (!(Number.isFinite(cueStart) && Number.isFinite(cueEnd) && cueEnd > cueStart)) {
                problems.push(`Invalid cue #${cueIndex}: start=${cueStart}, end=${cueEnd}, text="${cueWords.join('')}"`);
              } else {
                out += `${cueIndex++}\n${vttTime(cueStart)} --> ${vttTime(cueEnd)}\n${cueWords.join('')}\n\n`;
              }
              cueWords = []; cueStart = null; cueEnd = null;
            }

            for (const t of currentTokens) {
              if (t.state === 'del') continue;
              if (t.word === '\n') { flush(); continue; }
              cueWords.push(t.word);
              if (Number.isFinite(t.start)) cueStart = (cueStart == null) ? t.start : Math.min(cueStart, t.start);
              if (Number.isFinite(t.end)) cueEnd = (cueEnd == null) ? t.end : Math.max(cueEnd, t.end);
            }
            flush();

            if (problems.length) {
              console.error('⛔ VTT cue issues:\n' + problems.join('\n'));
              alert('בעיות ביצירת VTT:\n' + problems.slice(0, 30).join('\n') + (problems.length > 30 ? `\n…ועוד ${problems.length - 30}` : ''));
            }
            return out;
          }
          const buildJson = () => {
            const segs = [];
            let words = [];
            let pendingWS = '';
            let pendingS = Infinity;
            for (const t of currentTokens) {
              if (t.state === 'del') continue;
              if (t.word === '\n') {
                // ignore trailing pendingWS
                segs.push(words);
                words = [];
                pendingWS = '';
                pendingS = Infinity;
                continue;
              }
              const is_ws = /^\s$/u.test(t.word);
              if (is_ws) {
                pendingWS += t.word;
                if (Number.isFinite(t.start)) pendingS = Math.min(pendingS, t.start);
              } else {
                const start = Number.isFinite(pendingS) ? Math.min(pendingS, t.start) : t.start;
                words.push({ word: pendingWS + t.word, start, end: t.end });
                pendingWS = '';
                pendingS = Infinity;
              }
            }
            if (words.length) segs.push(words);
            const text = segs.map(ws => ws.map(w => w.word).join('')).join('\n');
            const out = {
              text,
              segments: segs.map(ws => {
                const startsArr = ws.filter(w => Number.isFinite(w.start)).map(w => w.start);
                const endsArr = ws.filter(w => Number.isFinite(w.end)).map(w => w.end);
                const t0 = startsArr.length > 0 ? Math.min(...startsArr) : 0;
                const t1 = endsArr.length > 0 ? Math.max(...endsArr) : 0.25;
                return { start: t0, end: t1, text: ws.map(w => w.word).join(''), words: ws };
              })
            };
            return JSON.stringify(out, null, 2);
          };

          const dl = (name, blob, type) => { const a = document.createElement('a'); const url = URL.createObjectURL(new Blob([blob], { type })); a.href = url; a.download = name; a.click(); setTimeout(() => URL.revokeObjectURL(url), 1000) };

          // ====== Playback UI
          const idxAt = t => { let lo = 0, hi = starts.length - 1, ans = -1; while (lo <= hi) { const m = (lo + hi) >> 1; if (starts[m] <= t) { ans = m; lo = m + 1 } else hi = m - 1 } if (ans >= 0 && t > (ends[ans] || starts[ans] + .25) && ans + 1 < starts.length && starts[ans + 1] <= t) ans++; return ans };
          const tick = () => { const t = player.currentTime, i = idxAt(t); if (i !== lastIdx) { if (lastIdx >= 0 && wordEls[lastIdx]) wordEls[lastIdx].classList.remove('active'); if (i >= 0 && wordEls[i]) { const el = wordEls[i]; el.classList.add('active'); } lastIdx = i } };
          player.addEventListener('timeupdate', tick);
          player.addEventListener('ratechange', () => { rate.value = String(player.playbackRate); rateVal.textContent = '×' + player.playbackRate.toFixed(2) });
          rate.oninput = () => { player.playbackRate = parseFloat(rate.value) || 1; rateVal.textContent = '×' + player.playbackRate.toFixed(2) };

          // ====== Settings modal
          const openM = () => { modal.classList.add('open'); hfTokenInput.value = getTok(); };
          const closeM = () => { modal.classList.remove('open'); };
          settingsBtn.onclick = openM; mClose.onclick = closeM; mSave.onclick = () => { setTok(hfTokenInput.value.trim()); closeM() }; mClear.onclick = () => { setTok(''); hfTokenInput.value = '' }; modal.addEventListener('click', e => { if (e.target === modal) closeM() });


          // ====== ButtonsZ;
          dlVttBtn.onclick = () => dl((document.title || 'transcript') + '.vtt', buildVtt(), 'text/vtt');

          // ====== Init
          (async () => { try { await loadFolders(); } catch (e) { console.log('שגיאה בדפדוף: ' + (e.message || e)); } })();
          // ---- Text size control (shared for transcript + diff) ----
          const root = document.documentElement;

          // Try to read an existing --text-size; fall back to computed transcript size
          function readInitialTextSizeRem() {
            const varVal = getComputedStyle(root).getPropertyValue('--text-size').trim();
            if (varVal.endsWith('rem')) return parseFloat(varVal);
            if (varVal.endsWith('px')) {
              const rootPx = parseFloat(getComputedStyle(root).fontSize) || 16;
              return parseFloat(varVal) / rootPx;
            }
            // fallback: derive from transcript
            const rootPx = parseFloat(getComputedStyle(root).fontSize) || 16;
            const trPx = parseFloat(getComputedStyle(transcriptEl).fontSize) || (1.10 * rootPx);
            return trPx / rootPx;
          }

          let fontSizeRem = readInitialTextSizeRem();

          function applyFontSize() {
            root.style.setProperty('--text-size', fontSizeRem.toFixed(2) + 'rem');
            // If you keep an inline size on the edit box, sync it too:
            if (editBox) editBox.style.fontSize = fontSizeRem.toFixed(2) + 'rem';
          }


          // Wire buttons
          fontPlus.onclick = () => {
            fontSizeRem = Math.min(fontSizeRem + 0.10, 2.00);
            applyFontSize();
          };
          fontMinus.onclick = () => {
            fontSizeRem = Math.max(fontSizeRem - 0.10, 0.60);
            applyFontSize();
          };

          // On load, ensure the var is set once
          applyFontSize();

          async function saveCorrection(filePath, jsonObj) {
            const { data, error } = await supa
              .from("corrections")
              .upsert(
                { file_path: filePath, json_data: jsonObj },
                { onConflict: "file_path" }   // ✅ important
              )
              .select();

            if (error) {
              console.error("❌ Save failed:", error);
              alert("שמירת תיקון נכשלה: " + (error.message || error));
              return null;
            }

            console.log("✅ Correction saved:", data);

            // 🔄 refresh global cache so the green/red marking is always accurate
            await loadAllCorrections();

            return data[0];
          }


          // ✅ Button handler calls saveCorrection()
          $('submitBtn').onclick = async () => {
            try {
              if (!validateChronology(currentTokens)) return;
              const json = JSON.parse(buildJson());

              const filePath = currentFileNode
                ? currentFileNode.dataset.folder + "/" + currentFileNode.dataset.file
                : null;

              if (!filePath) {
                alert("אין קובץ נבחר");
                return;
              }

              const saved = await saveCorrection(filePath, json);

              if (saved) {
                alert("✅ נשמר בהצלחה למסד הנתונים!");

                // refresh red/green status instantly
                const el = filesEl.querySelector(
                  `[data-file="${currentFileNode.dataset.file}"]`
                );
                if (el) el.style.background = "rgba(0,255,0,.08)";
              }
            } catch (e) {
              console.error(e);
              alert("❌ שגיאה בשמירת תיקון: " + e.message);
            }
          };


          // ====== Scroll-to-top button
          const scrollTopBtn = document.getElementById("scrollTopBtn");
          window.addEventListener("scroll", () => {
            scrollTopBtn.style.display = (document.documentElement.scrollTop > 300) ? "block" : "none";
          });
          scrollTopBtn.addEventListener("click", () => {
            const start = document.documentElement.scrollTop || document.body.scrollTop;
            const duration = 500; // ms
            const startTime = performance.now();

            function easeInOutQuad(t) {
              return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            }

            function step(now) {
              const elapsed = now - startTime;
              const progress = Math.min(elapsed / duration, 1);
              const eased = easeInOutQuad(progress);
              const current = start * (1 - eased);
              document.documentElement.scrollTop = current;
              document.body.scrollTop = current; // for Safari
              if (elapsed < duration) requestAnimationFrame(step);
            }

            requestAnimationFrame(step);
          });
        })();
      </script>

</body>

</html>